# niub
define offsetof(TYPE, MEMBER) ((size_t) &((TYPE*)0)->MEMBER)
对于这个宏可以大致分为5步： 
1. 0 
2. ((TYPE *)0) 
3. ( ((TYPE *)0)->MEMBER ) 
4. &( ((TYPE *)0)->MEMBER ) 
5. ( (size_t) &( ((TYPE *)0)->MEMBER )

1、内存地址开始于0； 
2、将0转换为type类型的结构体指针，换句话说就是让编译器认为这个结构体是开始于程序段起始位置； 
3、引用结构体中MEMBER成员； 
4、取地址符&，我们这里不关注结构体成员的内容，只取该成员的地址； 
5、将取到的地址强制转换为size_t类型。

因为这个结构体的起始地址被指定为0，所以取到的结构体成员的绝对地址(当转换为数字)就是这个成员在结构体中的偏移量。

这个代码之所以没有风险，是因为这里面没有写任何内存位置，甚至没有访问任何内存位置。只是操作了指向这些位置的指针，而指针一般存储在机器寄存器或是通常的本地堆栈。

以下代码也是正确的： 
( (size_t) &( ((TYPE *)3264)->MEMBER ) - 3264 )

以上代码中没有使用 0 ，而是使用的 3264 ，所以绝对地址要减去3264才是该成员相对于结构体首地址的偏移地址，当然实际使用中我们都是用的是 0 。